--- svm_common.c	2004-08-27 18:05:25.000000000 -0400
+++ svm_common.c	2005-02-16 09:22:04.878654928 -0500
@@ -14,23 +14,28 @@
 /*   author. The author is not responsible for implications from the    */
 /*   use of this software.                                              */
 /*                                                                      */
+/*   January 1, 2005 - Modifications by Tom Briggs                      */
 /************************************************************************/
-
-# include "ctype.h"
-# include "svm_common.h"
-# include "kernel.h"           /* this contains a user supplied kernel */
-
-long   verbosity;              /* verbosity level (0-4) */
-long   kernel_cache_statistic;
+#include "ctype.h"
+#include "svm_common.h"
+#include "kernel.h"           /* this contains a user supplied kernel */
+
+#include "global.h"           /* include global initializations */
+
+#ifdef MATLAB_MEX             /* include MATLAB headers as necessary */
+#include "mex.h"
+#include "matrix.h"
+#include "mexcommon.h"
+#endif 
 
 double classify_example(MODEL *model, DOC *ex) 
      /* classifies one example */
 {
   register long i;
-  register double dist;
+  register double dist = 0;
 
   if((model->kernel_parm.kernel_type == LINEAR) && (model->lin_weights))
-    return(classify_example_linear(model,ex));
+	
 	   
   dist=0;
   for(i=1;i<model->sv_num;i++) {  
@@ -63,14 +68,21 @@
 {
   double sum=0;
   SVECTOR *fa,*fb;
+  int cnta, cntb;
 
   /* in case the constraints are sums of feature vector as represented
      as a list of SVECTOR's with their coefficient factor in the sum,
      take the kernel between all pairs */ 
+  cnta = 0;
+  cntb = 0;
+
   for(fa=a->fvec;fa;fa=fa->next) { 
     for(fb=b->fvec;fb;fb=fb->next) {
-      if(fa->kernel_id == fb->kernel_id)
-	sum+=fa->factor*fb->factor*single_kernel(kernel_parm,fa,fb);
+      if(fa->kernel_id == fb->kernel_id) {
+	/*	sum+=fa->factor*fb->factor*single_kernel(kernel_parm,fa,fb); */
+	double tmp = single_kernel(kernel_parm,fa,fb);
+	sum += tmp;
+      }
     }
   }
   return(sum);
@@ -80,6 +92,7 @@
      /* calculate the kernel function between two vectors */
 {
   kernel_cache_statistic++;
+
   switch(kernel_parm->kernel_type) {
     case 0: /* linear */ 
             return((CFLOAT)sprod_ss(a,b)); 
@@ -91,7 +104,13 @@
             return((CFLOAT)tanh(kernel_parm->coef_lin*sprod_ss(a,b)+kernel_parm->coef_const)); 
     case 4: /* custom-kernel supplied in file kernel.h*/
             return((CFLOAT)custom_kernel(kernel_parm,a,b)); 
-    default: printf("Error: Unknown kernel function\n"); exit(1);
+  default: 
+#ifdef MATLAB_MEX
+    mexErrMsgTxt(ERR005);
+#else
+    printf("Error: Unknown kernel function\n"); 
+    exit(1);
+#endif
   }
 }
 
@@ -100,14 +119,17 @@
 {
   SVECTOR *vec;
   long    fnum,i;
+  /*  size_t size;   / * GCC says this is unused */
 
   fnum=0;
   while(words[fnum].wnum) {
     fnum++;
   }
   fnum++;
+
   vec = (SVECTOR *)my_malloc(sizeof(SVECTOR));
   vec->words = (WORD *)my_malloc(sizeof(WORD)*(fnum));
+
   for(i=0;i<fnum;i++) { 
       vec->words[i]=words[i];
   }
@@ -141,11 +163,11 @@
 void free_svector(SVECTOR *vec)
 {
   if(vec) {
-    free(vec->words);
+    my_free(vec->words);
     if(vec->userdefined)
-      free(vec->userdefined);
+      my_free(vec->userdefined);
     free_svector(vec->next);
-    free(vec);
+    my_free(vec);
   }
 }
 
@@ -249,7 +271,7 @@
     sumi->wnum=0;
 
     vec=create_svector(sum,"",1.0);
-    free(sum);
+  my_free(sum);
 
     return(vec);
 }
@@ -331,7 +353,7 @@
     sumi->wnum=0;
 
     vec=create_svector(sum,"",1.0);
-    free(sum);
+  my_free(sum);
 
     return(vec);
 }
@@ -399,7 +421,7 @@
     sumi->wnum=0;
 
     vec=create_svector(sum,a->userdefined,a->factor);
-    free(sum);
+  my_free(sum);
 
     return(vec);
 }
@@ -512,7 +534,7 @@
       if(example->fvec)
 	free_svector(example->fvec);
     }
-    free(example);
+    my_free(example);
   }
 }
 
@@ -633,8 +655,8 @@
 				      create_svector(words,comment,1.0));
   }
   fclose(modelfl);
-  free(line);
-  free(words);
+  my_free(line);
+  my_free(words);
   if(verbosity>=1) {
     fprintf(stdout, "OK. (%d support vectors read)\n",(int)(model->sv_num-1));
   }
@@ -678,12 +700,12 @@
 	free_example(model->supvec[i],1);
       }
     }
-    free(model->supvec);
+    my_free(model->supvec);
   }
-  if(model->alpha) free(model->alpha);
-  if(model->index) free(model->index);
-  if(model->lin_weights) free(model->lin_weights);
-  free(model);
+  if(model->alpha) my_free(model->alpha);
+  if(model->index) my_free(model->index);
+  if(model->lin_weights) my_free(model->lin_weights);
+  my_free(model);
 }
 
 
@@ -752,8 +774,8 @@
   } 
 
   fclose(docfl);
-  free(line);
-  free(words);
+  my_free(line);
+  my_free(words);
   if(verbosity>=1) {
     fprintf(stdout, "OK. (%ld examples read)\n", dnum);
   }
@@ -963,17 +985,119 @@
   return isspace(c);
 }
 
+
+/**
+ * my_free : call the apropriate operation to free a block
+ * of memory, and have it removed from the memory malloc_array 
+ * THB - 1/1/2005
+ ** */
+void my_free(void *ptr)
+{
+  if (ptr == NULL) {
+    /*    fprintf(stderr,"Warning: my_free called with NULL pointer, ignoring\n"); */
+    return;
+  }
+
+  /* remove the memory block from the allocated memory
+   * pool.  If the block is not in the malloc_array then
+   * it probably was not malloc'ed , or has been previously
+   * free()'d, so don't try to free it again. */
+  if (hash_delete(malloc_array, ptr)) {
+#ifdef MATLAB_MEX
+    mxFree(ptr);
+#else
+    free(ptr);
+#endif
+  }
+
+}
+
+/**
+ * my_realloc : call the apropriate operation to reallocate a 
+ * block of memory on the heap.  
+ * -THB 01/01/2005- 
+ */
+void *my_realloc(void *ptr, size_t size)
+{
+  void *newptr = NULL;
+
+  /* TODO: modify to use the malloc_array to check the ptr first */
+#ifdef MATLAB_MEX
+  if (ptr == NULL) 
+    mexErrMsgTxt(ERR010);
+
+  if (hash_delete(malloc_array, ptr)) {
+    newptr = mxRealloc(ptr,size);
+    hash_add(malloc_array, newptr);
+    return newptr;
+  }
+  else
+    mexErrMsgTxt(ERR011);
+
+#else
+  if (ptr == NULL) {
+    fprintf(stderr,"Warning: my_realloc() called with NULL pointer, ignoring\n");
+    return NULL;
+  }
+
+  if (hash_delete(malloc_array, ptr)) {
+    newptr = realloc(ptr,size);
+    hash_add(malloc_array, newptr);
+    return newptr;
+  }
+  else {
+    fprintf(stderr,"Error: realloc called on invalid pointer.\n");
+    return NULL;
+  }
+#endif
+
+}
+
+	
+/**
+ * my_malloc : dynamically allocate memory from the heap
+ * using the apropriate malloc operation. Uses the malloc_array
+ * to track blocks that have previously been allocated. 
+ * -THB 01/01/2005- 
+ */
 void *my_malloc(size_t size)
 {
   void *ptr;
-  ptr=(void *)malloc(size);
+
+#ifdef MATLAB_MEX
+  /* there is a buffer overrun somewhere in the code.  It happens
+   * in various places - because the overrun actually occurs 
+   * somewhere else in the code and is triggered only when
+   * another portion goes for the memory again. Adding 
+   * 128 bytes to the allocated block size creates overhead, but
+   * does correct the problem ( I think this nicely fits the definition
+   * of an engineering kludge).
+   */
+  ptr=(void *)mxMalloc(size + 128 );
+
+  /* ** add the ptr to the malloc array */
+  hash_add(malloc_array, ptr);
+
+  /* ** check the error code of malloc */
   if(!ptr) { 
-    perror ("Out of memory!\n"); 
-    exit (1); 
+    mexErrMsgTxt(ERR007);
   }
+
+#else
+  ptr=(void *)malloc(size);
+
+  hash_add(malloc_array, ptr);
+  
+  if (!ptr) {
+    perror("Out of memory!\n");
+    exit(1);
+  }
+#endif
+
   return(ptr);
 }
 
+
 void copyright_notice(void)
 {
   printf("\nCopyright: Thorsten Joachims, thorsten@joachims.org\n\n");
@@ -982,3 +1106,6 @@
   printf("The author is not responsible for implications from the use of this\n");
   printf("software.\n\n");
 }
+
+
+
